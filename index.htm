<!DOCTYPE html>
<html dir="ltr" class="client-js" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>Snake Game - Robot Project</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"Snake_Game","wgTitle":"Snake Game","wgCurRevisionId":193,"wgRevisionId":193,"wgArticleId":3,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":"User","wgUserGroups":["bureaucrat","sysop","*","user","autoconfirmed"],"wgCategories":[],"wgBreakFrames":!0,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Snake_Game","wgRelevantArticleId":3,"wgUserId":1,"wgUserEditCount":146,"wgUserRegistration":1448531748000,"wgUserNewMsgRevisionId":null,"wgIsProbablyEditable":!0,"wgRestrictionEdit":[],"wgRestrictionMove":[
]});mw.loader.implement("user.options",function($,jQuery){mw.user.options.set([]);});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"d6c6c02bdf319c82f6b2c533969a225c569c263e+\\","patrolToken":"083576413aeb8a22ab48426e15937da3569c263e+\\","watchToken":"900dd691d2b9ae9f02b2ca217e643d37569c263e+\\"});});mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","skins.vector.js"]);
} );</script>
<link rel="stylesheet" href="index_files/load.css">
<style>
.mw-collapsible-toggle{float:right;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}  .mw-content-ltr .mw-collapsible-toggle,.mw-content-rtl .mw-content-ltr .mw-collapsible-toggle{float:right} .mw-content-rtl .mw-collapsible-toggle,.mw-content-ltr .mw-content-rtl .mw-collapsible-toggle{float:left}.mw-customtoggle,.mw-collapsible-toggle{cursor:pointer} caption .mw-collapsible-toggle,.mw-content-ltr caption .mw-collapsible-toggle,.mw-content-rtl caption .mw-collapsible-toggle,.mw-content-rtl .mw-content-ltr caption .mw-collapsible-toggle,.mw-content-ltr .mw-content-rtl caption .mw-collapsible-toggle{float:none} li .mw-collapsible-toggle,.mw-content-ltr li .mw-collapsible-toggle,.mw-content-rtl li .mw-collapsible-toggle,.mw-content-rtl .mw-content-ltr li .mw-collapsible-toggle,.mw-content-ltr .mw-content-rtl li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}
.mw-spinner{background-color:transparent;background-position:center center;background-repeat:no-repeat}.mw-spinner-small{background-image:url(data:image/gif;base64,R0lGODlhFAAUAIQQAAYJBRkbGCYnJTI0MT9APk5QTVhZV2ZoZXR2c4SGg5CSj52fnKyuq7m7uMfJxtPV0v///////////////////////////////////////////////////////////////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCgABACwAAAAAFAAUAAAFc2AgjuNQkCipHCMAiI6TjoWAiG7gNM08CgTca+cbGWyBXEMm6okMJxGBNWLuGo8ngWBY+HgxlIFwm4VnimKKkWgn1Dzwwv0uxpfqfJWZ2p1hV0VXTA9gMCRETXxOOj08jXxfMo+NcHiUgT5nlAFZejqRKCEAIfkECQoADAAsAAAAABQAFAAABXYgI45jcZAouSSjIIjDkI4HwTJBIALvLBIFUY4xAPhoA1ZAcAjIRI2RQlFCkIIMR6PxEC0UiYXDt3WMSdOFz0w+prTb6DHeMNPd9LN7n9WjtGwjdnIzcGeGIn5aI3WMglFbWY14kHKLR4AMkZKEb2ebDF18fUchACH5BAkKAAEALAAAAAAUABQAAAV6YCCO44GQKOkw40CIxZuKi9KIwyAK8hwkCpyOIPCNFglWTjEojAgJkeMmUixIhiABADhIGw3HwycACLyqsI+ATo2NqCmY6puH5WC43QHvjxx8M3KBUnJGgyIPYIGEAVMjaiJ0j3lTjTN5eQGadWqainQpgJJ0b36jPiEAIfkECQoAAQAsAAAAABQAFAAABXVgII7jwpAo+TxjkoiGkY5OwwauSBTz2DSinIHQozUcuISCIIMpRDUfcoRYBAwCwQH6c9xSBAEBgapNUwfy7Fs0/oBFgBwwqL3bcwCvzYeey10qdkV2Uw+BAX9RIkc+RgE/iY1tkZGSlI2Wgz0OU5YBbG2dRSEAIfkECQoACAAsAAAAABQAFAAABXcgIo4j05Ao+TjjsohuOjoNi8RIoshjDb+KBG/mczUUL9EhSevZYKwDgSBE0GoPXmFgqBKfqIMXlR2iro3TMCBgF9BqXpt9MKPGJAeYRAhw81dDAwAAAyIPaTZgTSIChiJxTWlWPmaTk5SWPpiBPHqQcWV2VnskIQAh+QQJCgABACwAAAAAFAAUAAAFemAgjqPjkCj5nGLTiAyTlg3rios8t/bLLDvayeXIjRYsx4tHcjwCi0RCp6w9Z4qEQifcxXbXYNN1Cw7Og0O1vEMTEGKUYmfaGQaEQ7O6WxQEAwUiD0QiLCIEAiMEBCNLAUoBNwcAA3E3ZQIAYoVllI10PSMHCXGGhykhACH5BAkKAAEALAAAAAAUABQAAAV3YCCOo+OQKPmcYtOIZlo2T/sGDSvjrBs4t90vh6MRYbXh6Igc0mAuRzIV1UGtpJhsKpy5grKEOLEAfrvjBKOLUuy0KQTBkMiadwsDYS56RGEkBwQjBQZLMwEAAAEIAoZdPooiBAKQRJKMAgVCWpgBB25sAQUDQiEAIfkECQoAEAAsAAAAABQAFAAABXsgJI6j45Ao+Zxi04hmWjZP+0INK+OsCzm33S+HoxFhteHoiBzSYC5HMhXVQa2kmGwqnLmCsm8O+O2KseadNrVQKBhZsnqRSChEj6iIQEIURm5LIwMBCAIBEAkDB10QAAIQAYgQBnxChyKYiQSMOwKQEJ8jCQuNIgd/OyEAIfkECQoAHwAsAAAAABQAFAAABXzgJ46j45Ao+Zxi04hmWjZP+34NK+Os+zm33S+HoxFhteHoiBzSYC5HMhXVQa2kmGwqnLmCsm8O+O2KsV0u6UDYAbWigwAg2K2iIgMAMPgsDCQMCkssCW0iBQMKA30MCQtdHwNtjCILCV0EfZKbDY9CBAUimiMMaDIIgDshACH5BAkKAB8ALAAAAAAUABQAAAV44CeOo+OQKPmcYtOIZlo2T/t+DSvjrPs5t90vh6MRYbXh6Igc0mAuRzIV1UGtpJhsKhwVAGBA1xUdhMVCMrMr4pIQhx1QK0IQBITdKio6CAQFHwsIWUFHCoEiBgQKCQlDWCkEgY5QXQV5H5WQQgWJmx8PbjsMC0IhACH5BAkKAB8ALAAAAAAUABQAAAV14CeOo+OQKPmcYtO0bwo/cC3b7pffotOcrsevRPsMBKMh8eNrFAcBwEBxczlRUMLNdEvwUgWAGPC1/gZjMs9c/I7aqMRh62KJEoZB4bay3gkEcw4LJD5JMQtzIgsKfj52XVQ7OzcKVDoxQjEyCoSYb3A8XDchACH5BAEKAB8ALAAAAAAUABQAAAV64CeOo+OQKJkcY9OIZjoSAPu5Ii6LgJC/jtdONKjdGo/GCfYQEQYjAYHkaAaVosJgUFjsXDHS07ALpxTDFOK5TbvAh217+MamSU0Zg1FWLkUMCgloMg9XSwwJCV6GVEI3Sw5eMEg4QX9fJzo6X0I6SZgoYZwPeXdmKSEAOw==);background-image:url(http://localhost/mediawiki-1.26.0/resources/src/jquery/images/spinner.gif?ca65b)!ie;height:20px;width:20px; min-width:20px}.mw-spinner-large{background-image:url(data:image/gif;base64,R0lGODlhIAAgAOMAAP///wAAAMbGxoSEhLa2tpqamjY2NlZWVtjY2OTk5Ly8vB4eHgQEBP///////////yH/C05FVFNDQVBFMi4wAwEAAAAh+QQFCgAPACwAAAAAIAAgAAAE5/DJSWlhperN52JLhSSdRgwVo1ICQZRUsiwHpTJT4iowNS8vyW2icCF6k8HMMBk+EDskxTBDPZwuAkkqIfxIQyhBQBFvHwSDITM5VDW6XNE4KagNh6Bgwe60smQUB3d4Rz1ZBApnFASDd0hihh12BkE9kjAJVlycXIg7CQIFA6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YJvpJivxNaGmLHT0VnOgSYf0dZXS7APdpB309RnHOG5g/qXGLDaC457D1zZ/V/nmOM82XiHRLYKhKP1oZmADdEAAAh+QQFCgAPACwAAAAAGAAXAAAEcvDJSesiNetplqlDsYnUYlIGw2jGV55SoS5sq0wmLS3qoBWtAw42mG0ehxYp90CoGKRNy8U8qFzNweCGwlJkgolCq0VIEAbMkUIghxLrDcLti2/Gg7D9qN774wkKBIOEfw+ChIV/gYmDho+QkZKTR3p7EQAh+QQFCgAPACwBAAAAHQAOAAAEcvDJSScxNev9jjkZwU2IUhkodSzLKA2DOKGYRLD1CA/InEoGlkui2PlyuKGkADM9aI8EayGbJDYI4zM1YIEmAwajkCAoehNmTNNaLsQMHmGuuEYHgpHAAGfUBHNzeUp9VBQJCoFOLmFxWHNoQweRWEocEQAh+QQFCgAPACwHAAAAGQARAAAEavDJ+cQQNOtdRsnf9iRINpyZYYgEgU3nQKnr1hIJjEqHGmqIlkInexRUB5FE0So9YhKaUpK4SaAPlWaxIFAETQ3B4BxzF2Kn8nBeJKebdm3SgksKXDt8kNP7/xoMgoMLP36DiAyAD4kMhREAIfkEBQoADwAsDgAAABIAGAAABGUQFfSqvZiUghXF1cZZxTCA4WYh5omKVqugD/woLV2rT/u9KoJpFDIYaIJBwnIwGogoivOoq0wPs6r1qe16v5WFeEzVjc+LKnphIIC9g193wGC4uvX6Aoo05BllVQULeXdadAxuEQAh+QQFCgAPACwOAAAAEgAeAAAEgDCp9Kq9WBGFBb5ECBbFV4XERaYmahGk14qPQJbm4z53foq2AquiGAwQJsQQYTRyfIlCc4DzTY8+i8CZxQy74KxhTD58P+S0Qaw+hN8WyruwWMDrdcM5ecAv3CYDDDIEBngmBwwMaxeGJgmKDFVdggx2bwuKA28EkXAGinJhVCYRACH5BAUKAA8ALA8AAQARAB8AAAR88Mn5UKIYC0KyT5ziZQqHjBQSohRHXGzFCSkHU/eTlCa7uTSUi6DIeVSEU0yiXDo9g6i0EIRKr6hrlPrsOgkGQ8EZDh+eZcOosKAcymPKYLE4TwphCWMvoS86HnsME3RqgXwSBnQjghR+h4MTB4sZjRiAGAsMbU4FDHFLEQAh+QQFCgAPACwIAA4AGAASAAAEbPDJSesjOKtk+8yg4nkgto1oihIqKgyD2FpwjcxUUtRDMROG2wPBkz0EjEHHYKgoYMKHgcE4PBZYCbM5KlAZHOxCUmBaPQuq8pqVHJg+GnUsEVO2nTQjzqZPmB1UXHVtE3wVOxUGC4M4H34qEQAh+QQFCgAPACwCABIAHQAOAAAEePDJSat96FJ0tEUEkV0DwwwepYSEklDEYpopJbCEIBkzY+geweD1SKxCiJJpUZAgmBbCYNCcIFaJggk1OSwWKINYMh2MLMRJ7LsbPxTl2sTAbhsmhalC/vje7VZxNXQLBHNuEnlcKV8dh38TCmcehhUHBo58cpA1EQAh+QQFCgAPACwAAA8AGQARAAAEZ7AsRuu7OOtbO9tgJnlfaJ7omQwpuixFCxrvK2dHvRwoQmw1w+8i3PgIggzBpjEYLoPohUBNoJzPR5T1OCpOB2dMK70oqIhQwcmDlh8J6nCDzWwzAmrIqblnEFZqGgUDYzcaAgNJGxEAIfkEBQoADwAsAQAIABEAGAAABFyQMDaevfiOyVbJ4GNwjCGEWLGQaLZRbYZUcW3feK7vaGEYNsXh96sRgYiW73e4JAYn0O9zKQwGhAdhi5pdLdts6DpQgLkgBfkSHl+TZ7ELi2mDEHKLgmC+JRQJEQAh+QQFCgAPACwAAAIADgAdAAAEcvDJ+cqgeDJmMt4M4U3DtozTsl1oASJpRxnbkS6LIT4Cw0oHHO4A8xAMwhPqgSssH4nnknAwWK+Zq1ZGoW650vAOpRgMBCOEee2xrAtRTNlcQEsI8Yd6oKAICARFHgmAYx4KgIIZCIB9ZIB5RgR2KAmKEQA7);background-image:url(http://localhost/mediawiki-1.26.0/resources/src/jquery/images/spinner-large.gif?57f34)!ie;height:32px;width:32px; min-width:32px}.mw-spinner-block{display:block; width:100%}.mw-spinner-inline{display:inline-block;vertical-align:middle; zoom:1;*display:inline}
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}.suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left; overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}.suggestions-result-current{background-color:#4C59A6;color:white}.suggestions-special .special-label{color:gray;text-align:left}.suggestions-special .special-query{color:black;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:silver}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:white}.highlight{font-weight:bold}
.postedit-container{margin:0 auto;position:fixed;top:0;height:0;left:50%;z-index:1000;font-size:13px}.postedit-container:hover{cursor:pointer}.postedit{position:relative;top:0.6em;left:-50%;padding:.6em 3.6em .6em 1.1em;line-height:1.5625em;color:#626465;background-color:#f4f4f4;border:1px solid #dcd9d9;text-shadow:0 0.0625em 0 rgba(255,255,255,0.5);border-radius:5px;box-shadow:0 2px 5px 0 #ccc;-webkit-transition:all 0.25s ease-in-out;-moz-transition:all 0.25s ease-in-out;-ms-transition:all 0.25s ease-in-out;-o-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out}.skin-monobook .postedit{top:6em !important}.postedit-faded{opacity:0}.postedit-icon{padding-left:41px;  line-height:25px;background-repeat:no-repeat;background-position:8px 50%}.postedit-icon-checkmark{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABblBMVEUAAAD///////9PfTf///80aRdTgjn///9Feij///////////9Rfzf///////////9PfjZRgDh1o1xOfTb///////+bwYqLtnj///////9PfTa82K////9WhT6YxIL///9QgDdTgzr////////j7uDl7eLq8efi693k7OH///////9UhjuBr2rp9uRUhjr///9YljVKgir///9WiTlYjT3////9/v57vFlbkT5PjC9dlD/5/fhuq09stUTs9uhxuElctCpfnT1huDFloEZloUZmpENmvDZpvDxpvTxqvjxrvT5rvT9rwTxsqktswD5uwkBvuUdxw0NztFBztU9ztVBzwkp0tlJ1xkd2t1R3uVR4w1F4xk54x014yE15uVZ5v1R5xVB6v1R7yFJ8wVh9xVl9yFR9yVd9ylN+xVh+yFd/x1l/yFeAylmEx1+Ny2uY0Hqe04Wj1Ymv3Ze33qLD47TJ5L3O6cPU7Mrq9eb2+/Q4j37OAAAAQHRSTlMAAQIEBAUFBQwPFB4fJCUoKiosQEhJS01RUlZZXmdydXaChYuSlJSWmJmoq6uur8LExcvM19fg5ejt8fX2+Pr7SljgewAAAKpJREFUGBkFwQNCAwAAAMDLtl3LtrG4rWXbtvX77gAgZ6grFwC0bhwNVgKgdPZx8b0dgLi+s7Wn0VoAqpfOI9+BNADZI7fLrz2pSEwGHZuH+78lSK8ZLkLezF3ooyUG3VPXq2USei9WngeyoG195yBYWDF3E/2pAhl1e9Gr8bGT+bfOFCC2fnvh4X7rcqIAQNNu+HT6sxkAjceTL/2ZAIhv+PorBwBJxfkA//dFHSCBy/UTAAAAAElFTkSuQmCC);background-image:url(http://localhost/mediawiki-1.26.0/resources/src/mediawiki.action/images/green-checkmark.png?9048a)!ie;background-position:left}.postedit-close{position:absolute;padding:0 .8em;right:0;top:0;font-size:1.25em;font-weight:bold;line-height:2.3em;color:black;text-shadow:0 0.0625em 0 white;text-decoration:none;opacity:0.2;filter:alpha(opacity=20)}.postedit-close:hover{color:black;text-decoration:none;opacity:0.4;filter:alpha(opacity=40)}</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{color:black;text-decoration:none}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:white}.suggestions a.mw-searchSuggest-link .special-query{ overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="index_files/load_002.css">
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}</style>
<script async="" src="index_files/load.php"></script>
<meta name="generator" content="MediaWiki 1.26.0">
<link rel="alternate" type="application/x-wiki" title="Edit" href="http://localhost/mediawiki-1.26.0/index.php?title=Snake_Game&amp;action=edit">
<link rel="edit" title="Edit" href="http://localhost/mediawiki-1.26.0/index.php?title=Snake_Game&amp;action=edit">
<link rel="shortcut icon" href="http://localhost/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://localhost/mediawiki-1.26.0/opensearch_desc.php" title="Robot Project (en)">
<link rel="EditURI" type="application/rsd+xml" href="http://localhost/mediawiki-1.26.0/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="Robot Project Atom feed" href="http://localhost/mediawiki-1.26.0/index.php?title=Special:RecentChanges&amp;feed=atom">
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mediawiki-1.26.0/skins/Vector/csshover.min.htc")}</style><![endif]-->
<script src="index_files/load_002.php"></script><script>try {  for(var lastpass_iter=0; lastpass_iter < document.forms.length; lastpass_iter++){    var lastpass_f = document.forms[lastpass_iter];    if(typeof(lastpass_f.lpsubmitorig)=="undefined"){      if (typeof(lastpass_f.submit) == "function") {        lastpass_f.lpsubmitorig = lastpass_f.submit;        lastpass_f.submit = function(){          var form = this;          try {            if (document.documentElement && 'createEvent' in document)            {              var forms = document.getElementsByTagName('form');              for (var i=0 ; i<forms.length ; ++i)                if (forms[i]==form)                {                  var element = document.createElement('lpformsubmitdataelement');                  element.setAttribute('formnum',i);                  element.setAttribute('from','submithook');                  document.documentElement.appendChild(element);                  var evt = document.createEvent('Events');                  evt.initEvent('lpformsubmit',true,false);                  element.dispatchEvent(evt);                  break;                }            }          } catch (e) {}          try {            form.lpsubmitorig();          } catch (e) {}        }      }    }  }} catch (e) {}</script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Snake_Game skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">Snake Game - Màdara</h1>
									<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From Robot Project</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="en"><div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Final1.jpg" class="image"><img alt="" src="index_files/300px-Final1.jpg" class="thumbimage" srcset="/mediawiki-1.26.0/images/thumb/8/88/Final1.jpg/450px-Final1.jpg 1.5x, /mediawiki-1.26.0/images/thumb/8/88/Final1.jpg/600px-Final1.jpg 2x" height="533" width="300"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Final1.jpg" class="internal" title="Enlarge"></a></div>Màdara final version</div></div></div>
<p><b>Màdara</b> is a robot designed for the Snake Game Competition 
organized as a project for the Operating Systems course at Eurecom. 
Refer to the official website at this <a rel="nofollow" class="external text" href="http://soc.eurecom.fr/OS/projects_fall2015.html">link</a> for the complete set of specifications. 
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="#" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Specifications_summary"><span class="tocnumber">1</span> <span class="toctext">Specifications summary</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Robot_architecture"><span class="tocnumber">2</span> <span class="toctext">Robot architecture</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Sensors_and_actuators"><span class="tocnumber">2.1</span> <span class="toctext">Sensors and actuators</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#Encoders"><span class="tocnumber">2.1.1</span> <span class="toctext">Encoders</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Ultrasonic_Sensor"><span class="tocnumber">2.1.2</span> <span class="toctext">Ultrasonic Sensor</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Gyroscope"><span class="tocnumber">2.1.3</span> <span class="toctext">Gyroscope</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Compass"><span class="tocnumber">2.1.4</span> <span class="toctext">Compass</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Color_Sensor"><span class="tocnumber">2.1.5</span> <span class="toctext">Color Sensor</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Algorithms"><span class="tocnumber">3</span> <span class="toctext">Algorithms</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Reference_system"><span class="tocnumber">3.1</span> <span class="toctext">Reference system</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Basic_functions"><span class="tocnumber">3.2</span> <span class="toctext">Basic functions</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="#Odometry"><span class="tocnumber">3.2.1</span> <span class="toctext">Odometry</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Motor_control"><span class="tocnumber">3.2.2</span> <span class="toctext">Motor control</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Gyroscope_calibration_and_reading"><span class="tocnumber">3.2.3</span> <span class="toctext">Gyroscope calibration and reading</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Compass_calibration_and_reading"><span class="tocnumber">3.2.4</span> <span class="toctext">Compass calibration and reading</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#Controller_based_on_encoders.2C_gyroscope_and_compass"><span class="tocnumber">3.2.5</span> <span class="toctext">Controller based on encoders, gyroscope and compass</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#Ball_detection_and_grab_with_check"><span class="tocnumber">3.2.6</span> <span class="toctext">Ball detection and grab with check</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#Obstacle_detection_and_avoidance"><span class="tocnumber">3.2.7</span> <span class="toctext">Obstacle detection and avoidance</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Go_to_position"><span class="tocnumber">3.2.8</span> <span class="toctext">Go to position</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Blueetooth_module"><span class="tocnumber">3.2.9</span> <span class="toctext">Blueetooth module</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21"><a href="#Complex_functionality"><span class="tocnumber">3.3</span> <span class="toctext">Complex functionality</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#Main_architecture"><span class="tocnumber">3.3.1</span> <span class="toctext">Main architecture</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#FSM_description_of_the_overall_behavior"><span class="tocnumber">3.3.2</span> <span class="toctext">FSM description of the overall behavior</span></a>
<ul>
<li class="toclevel-4 tocsection-24"><a href="#I_am_me"><span class="tocnumber">3.3.2.1</span> <span class="toctext">I am me</span></a></li>
<li class="toclevel-4 tocsection-25"><a href="#Leader"><span class="tocnumber">3.3.2.2</span> <span class="toctext">Leader</span></a></li>
<li class="toclevel-4 tocsection-26"><a href="#Follower"><span class="tocnumber">3.3.2.3</span> <span class="toctext">Follower</span></a></li>
<li class="toclevel-4 tocsection-27"><a href="#Go_back_home"><span class="tocnumber">3.3.2.4</span> <span class="toctext">Go_back_home</span></a></li>
<li class="toclevel-4 tocsection-28"><a href="#Get_the_ball"><span class="tocnumber">3.3.2.5</span> <span class="toctext">Get the ball</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-29"><a href="#Videos"><span class="tocnumber">4</span> <span class="toctext">Videos</span></a>
<ul>
<li class="toclevel-2 tocsection-30"><a href="#Perfect_square_after_compass_calibration"><span class="tocnumber">4.1</span> <span class="toctext">Perfect square after compass calibration</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Perfect_360.C2.B0_turn_with_the_controller_based_on_the_gyroscope_only."><span class="tocnumber">4.2</span> <span class="toctext">Perfect 360° turn with the controller based on the gyroscope only.</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Leader_2"><span class="tocnumber">4.3</span> <span class="toctext">Leader</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Follower_2"><span class="tocnumber">4.4</span> <span class="toctext">Follower</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Having_fun_with_Wall_EV3"><span class="tocnumber">4.5</span> <span class="toctext">Having fun with Wall_EV3</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-35"><a href="#How_to_work_with_EV3"><span class="tocnumber">5</span> <span class="toctext">How to work with EV3</span></a>
<ul>
<li class="toclevel-2 tocsection-36"><a href="#Robot_Setup"><span class="tocnumber">5.1</span> <span class="toctext">Robot Setup</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="#Source_Code"><span class="tocnumber">5.2</span> <span class="toctext">Source Code</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#Compile_and_Linking"><span class="tocnumber">5.3</span> <span class="toctext">Compile and Linking</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="#Download_and_run_the_project"><span class="tocnumber">5.4</span> <span class="toctext">Download and run the project</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-40"><a href="#Work_organization"><span class="tocnumber">6</span> <span class="toctext">Work organization</span></a></li>
<li class="toclevel-1 tocsection-41"><a href="#Work_division"><span class="tocnumber">7</span> <span class="toctext">Work division</span></a></li>
<li class="toclevel-1 tocsection-42"><a href="#Team_members"><span class="tocnumber">8</span> <span class="toctext">Team members</span></a></li>
</ul>
</div>

<h3><span class="mw-headline" id="Specifications_summary">Specifications summary</span></h3>
<p>A square arena contains some balls at predefined positions. A snake 
made of several robots communicating through a bluetooth server 
navigates in the arena led by the first robot. As soon as the first 
robot finds and grabs a ball, it comes back to the starting position and
 it passes the leadership to the following one.
The robot has thus to cover two roles:
</p>
<ul><li> Leader: the robot navigates in the arena trying to find a ball,
 grab it, and bring it back to the starting area. During these 
operations he synchronizes with the following robots in order to make 
the entire snake move smoothly behind him;</li>
<li> Follower: the robot has to synchronize with the preceding and following robots in order to make the snake move correctly.</li></ul>
<h1><span class="mw-headline" id="Robot_architecture">Robot architecture</span></h1>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Building1.jpg" class="image"><img alt="" src="index_files/300px-Building1.jpg" class="thumbimage" srcset="/mediawiki-1.26.0/images/thumb/e/e7/Building1.jpg/450px-Building1.jpg 1.5x, /mediawiki-1.26.0/images/thumb/e/e7/Building1.jpg/600px-Building1.jpg 2x" height="225" width="300"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Building1.jpg" class="internal" title="Enlarge"></a></div>Building the robot</div></div></div>
<p>The choice of the robot architecture is a fundamental step in the 
design. The avalilable components are three motors with integrated 
encoders, an ultrasonic sensor, a compass, a gyroscope and a color 
sensor. A careful analysis of the specifications is necessary.
First of all the basic functions that the robot must perform should be 
identified.
</p>
<ul><li> <b>Navigation and odometry</b>: the robot must be able to 
navigate in two different arenas delimited by two different kind of 
borders. At the moment of defining the architecture the exact arena 
configurtion is not yet completely known. The design must thus be very 
general and it must not relay on specific assumptions. Once the robot 
grabs the ball it must come back to the starting position. This means 
that at least when coming back the robot must have knowledge of his 
position. Since the robot communicates its movements to the following 
ones and must be able to follow the previous one based on this messages,
 it must be able to move of a predefined distance at a predefined speed 
in a given direction. For these reasons the best approach is to 
implement basic motion functions that allow to turn to an absolute angle
 and move straightforward keeping track of the current position in the 
arena through simple odometry techniques. The classic configuration for 
this kind of robots is a structure with two wheels controlled by two 
motors and a third auto-pivoting. To simplify odometry computations the 
only allowed operations are rotation and translation but not 
rototranslation. In other words the two wheels can turn only at the same
 or opposite speed. The motors provided already include encoders for 
feedback and the library already includes controllers to keep predefined
 speeds and turn of given angles. While the encoders precision and the 
PID controllers performace are sufficient for running forward, gyroscope
 and compass sensors are necessary to properly turn. Calibration and a 
custom controller are necessary. The gyroscope measures turning speed, 
the device performs integration to provide a relative angle value. It is
 very precise but is suffers from drift over time and vibrations during 
the turn. It is placed near the robot center, in a very stable position.
 Since it is mechanical (MEMS) it does not suffer from electromagnetic 
noise. The compass is instead much sensitive to noise from the brick and
 from the motors and actuators so it must be placed as far as possible 
from them on the top of the robot. Care must be taken in keeping it 
stable and well aligned.</li>
<li> <b>Ball and obstacle detection</b>: during navigation the robot 
must be able to detect objects. The only available sensor is the 
ultrasonic one. Unfortunately its range and directivity are quite bad 
for this task. It is very important to properly place it in the front of
 the  robort, at ball height, horizontally. Calibration and a proper 
algorithm allow to detect and find a ball. Wall and obstacles can be 
distinguished from balls exploiting the robot knowledge of his position 
and its role. However, to improve this feature a color sensor is added 
on the arm. This also allows to check if the ball was actually grabbed 
or if the operation failed. </li>
<li> <b>Ball grabbing</b>: the robot stops when the sensor is in front 
of the ball, so the arm must be in front of the sensor. However if the 
ball is just grabbed, the sensor cannot be used to detect obstacles 
anymore. Since obstacles are more likely to be present while going back 
home (other robots in the snake or other balls) this is very bad. For 
this reason an arm able to lift the ball after having grabbed it is 
designed. Since only one actuator is available for the arm, the complex 
dual step movement must be implemented mechanically as shown in the 
figures. </li>
<li> <b>Communication</b>: to easily communicate with the robot during 
development and additional wifi module is added. This also allows to 
communicate with a custom server to simulate several steps of the game 
for debugging.</li></ul>
<h2><span class="mw-headline" id="Sensors_and_actuators">Sensors and actuators</span></h2>
<p>A complete (as far as required) specification of the sensors can be found at this <a rel="nofollow" class="external text" href="http://www.ev3dev.org/docs/sensors/">link</a>.
</p>
<h3><span class="mw-headline" id="Encoders">Encoders</span></h3>
<p>They are used for the motors, so it is possible to specify the type 
of movement, such as example turn absolute that is used for the arm, or 
turn relative that is useful for the movement of the wheels.
The returned value is the number of turns degree of the motor and is 
expressed in tachometers.
To convert these values into real ones we used some conversion 
functions, for example for the wheel's motors we taking into account the
 size of the wheels.
We also use the encoders to know the actual position but when the wheel 
slip the robot thinks to be in a position but in the reality it is in 
another one.
</p>
<h3><span class="mw-headline" id="Ultrasonic_Sensor">Ultrasonic Sensor</span></h3>
<p>This sensor works issuing sound waves that if reach an object are 
reflected and come back to the sensor.
It give us values that are time intervals, in which the waves return to 
sensor, so we use a formula to transform time into distance.
They are influenced by a lot of factors like distance from the floor, 
presence of other sensors that works on the same frequency and the angle
 of reflection. For these reasons it sometimes gives false positives.
</p>
<h3><span class="mw-headline" id="Gyroscope">Gyroscope</span></h3>
<p>This sensor measures the angular speed of rotation around an axis 
and, consequently, the angle of rotation on that axis. It has different 
modes of work and can return values such the angle of rotation and the 
rotation speed.
For our project we use this sensor with the compass in order to obtain 
better performances.
The main weakness is that it is a mechanical sensor so it is influenced 
by the temperature, since the metal parts suffer from thermal expansion.
 For this reason it piles up errors that may derive the real measure.
</p>
<h3><span class="mw-headline" id="Compass">Compass</span></h3>
<p>This sensor allow us to do absolute rotations since it returns a 
value in degrees that indicates the angle respect the north, that for 
little distances is always the same. In this way we avoid the problem of
 sum errors at every measurement. Before use it we have to calibrate it 
in different strategic places inside the arena in order to obtain an 
optimal result.
The problem of this sensor is that it suffers from electromagnetic 
fields which compromise the measures, then sometimes it's very difficult
 to use it into labs in which there are a lot of electronic devices.
Outside Eurecom we never had these problems, while we have them in the 
little arena.
</p>
<h3><span class="mw-headline" id="Color_Sensor">Color Sensor</span></h3>
<p>This sensor works using a light beam and has different modes of 
working.
We use it in the colour mode, where it returns an integer that indicates
 a specific colour (1 Black, 2 Blue, 3 Green...and so on). In our case 
we discovered that it has problems to detect the colour blue, moreover 
it detects colours only at very little distances.
</p><p><br>
</p>
<div class="thumb tright"><div class="thumbinner">

<iframe width="300" height="170" src="https://www.youtube.com/embed/0klZ_4R96o8" frameborder="0" allowfullscreen></iframe>
<div class="thumbcaption">Arm: grab and lift the ball</div></div></div>
<h1><span class="mw-headline" id="Algorithms">Algorithms</span></h1>
<h2><span class="mw-headline" id="Reference_system">Reference system</span></h2>
<p>The following reference system is considered by the robot:
</p>
<ul><li>the bottom left angle is the origin of the cartesian system that
 has axis y along the left border oriented to up and the x axis along 
the bottom border oriented to right.</li>
<li>the reference 0 angle is along the y axis. The angle increase clockwise.  </li></ul>
<h2><span class="mw-headline" id="Basic_functions">Basic functions</span></h2>
<h3><span class="mw-headline" id="Odometry">Odometry</span></h3>
<p>In each of the following functions the robot knows its position 
(x,y,t) in the previously described reference system. Each time the 
robot moves of a certain distance d in a given angle w, at the end of 
the movement its position is updated according to the following simple 
relations:<br>
</p>
<pre> x += d*sin(w*PI/180)
 y += d*sin(w*PI/180)
 t = w
</pre>
<p>If the robot is in a given postition x,y and wants to reach a 
destination X,Y it must compute the angle and distance that it has to 
cover according to these simple relations:<br><br>
<a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/Polar.png" class="image"><img alt="Polar.png" src="index_files/Polar.png" height="163" width="549"></a><br><br>
Usually the position is updated on the basis of the target one since 
this gives the best accuracy. However if the robot stops in the middle 
of a movement due to an obstacle or cancel message, the actual distance 
is measured with the encoders.
</p>
<h3><span class="mw-headline" id="Motor_control">Motor control</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Motor_controller.png" class="image"><img alt="" src="index_files/300px-Motor_controller.png" class="thumbimage" srcset="/mediawiki-1.26.0/images/thumb/5/5b/Motor_controller.png/450px-Motor_controller.png 1.5x, /mediawiki-1.26.0/images/thumb/5/5b/Motor_controller.png/600px-Motor_controller.png 2x" height="232" width="300"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Motor_controller.png" class="internal" title="Enlarge"></a></div>PID</div></div></div>
<p>Some predefined controllers available in the library that exploit the
 encoders can be used.
As far as the arm is concerned a predefided function that makes the 
motor turn of an absolute angle is used. Each time the robot is turned 
on with the arm down this angle becomes the zero reference for the 
encoder control. The grab position can be reached turning of a 
precomputed absolute angle. When the arm reaches one of the positions, a
 <a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/PID_controller">PID controller</a>
 is started in order to keep that position. Two functions called 
grab_and_check and drop_the_ball are incluede in the lib/ev3lib_ball 
library. They are blocking.
To go straight for a certain distance at a certain speed one PID 
controller for each motor is started giving a reference speed (computed 
with a simple mapping from speed in cm/s to tachocounts/s). The motors 
stop after having turned for a given number of counts, computed with a 
simple mapping between cm and counts (considering the diameter of the 
wheels). When the final position is reached, a PID controller is set to 
keep it. If the speed to reach is quite high, a step command is not 
suitable. In fact it makes the wheel slip on the floor loosing 
precision. For this reason the possibility of using ramp commands is 
included. A run_relative(cm) function is included in the 
lib/ev3lib_motor library. It is a non-blocking function. A flag must be 
checked to see when it finishes. This allows to poll/check also other 
conditions. For instance it is possible to look for the presence of an 
obstacle while running. This function is properly called by higher-level
 ones and never directly in the main application. To turn of a given 
angle the two motors are given a command to turn of a relative angle 
simply  computed taking into account the wheel diameter and the distance
 between them. Again a PID is started to keep the final position. A 
turn_relative(angle) function is included in the lib/ev3lib_motor 
library. Encoders do not provide a good accuracy for this turn. This 
function is never called directly in the main application, but it is 
called by higher-level functions that also handle gyroscope and compass 
values.
</p>
<h3><span class="mw-headline" id="Gyroscope_calibration_and_reading">Gyroscope calibration and reading</span></h3>
<p>The device is able to integrate its measurements to compute an 
absolute angle that can be read. At initialization the zero position is 
calibrated so that each value is given in the chosen reference system.
</p>
<h3><span class="mw-headline" id="Compass_calibration_and_reading">Compass calibration and reading</span></h3>
<p>The compass provides an absolute measurement of the angle w.r.t. to 
the north. Since the distances inside the arenas are quite short, this 
value is condidered to be constant. The values read from the compass are
 quite stable and don't reaquire any additional filtering. However the 
magnetic field is strongly influenced by external sources, so the values
 change in different positions of the arena. Moreover in a given 
position the results are not linear. To solve this problem multiple 
calibrations can be performed. A simple goniometer is used as reference 
to calibrate 8 angle values in 4 different positions of the arena. These
 32 values are stored into a file that is loaded into memory at run 
time. Given a certain angle it is possible to retrieve the corresponding
 measurement value of the nearest calibrated angle. The choice of the 
calibration point is based on the x,y position in the arena, selecting 
the nearest one. This mechanism is exploited by the function responsible
 for absolute turns. The main goal is to have in each position a good 
absolute angular reference. This solves the drift problem from which the
 gyroscope is affected. It is possible to reach a calibration angle 
known with high accuracy and then turn relatively of a small angle 
exploiting the gyroscope that does not suffer from drift if the time 
between two measurements is small. The encoders as well are good for 
small turns starting from a known position. As for the gyroscope the 
zero position is calibrated at the beginning by saving the arena heading
 and then subrating it from each reading. The calibration functions are 
part of the library lib/ev3lib_motor_controller. The program <b>calibration</b>
 calls it providing a nice user-friendly interface for calibrating the 
compass in one position and saving the points to file. A complete file 
for all positions can be then easily created editing the different files
 created even independently. It is very important to calibrate the 
compass before each competetion, especially if the position of the arena
 changes. This feature allows great accuracy in the movements, however 
it is also very critical for the performace and must be performed with 
much care.
</p>
<h3><span class="mw-headline" id="Controller_based_on_encoders.2C_gyroscope_and_compass">Controller based on encoders, gyroscope and compass</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Controller.png" class="image"><img alt="" src="index_files/300px-Controller.png" class="thumbimage" srcset="/mediawiki-1.26.0/images/thumb/d/de/Controller.png/450px-Controller.png 1.5x, /mediawiki-1.26.0/images/thumb/d/de/Controller.png/600px-Controller.png 2x" height="232" width="300"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Controller.png" class="internal" title="Enlarge"></a></div>controller</div></div></div>
<p>The best approch is to build a filter between the angle values that 
can be retrieved from the encoders, the gyroscope and the compass. For 
instance a Karman filter. This allows to compute a value of the current 
angle with low uncertainty and then build a controller based on this 
measure for the feedback. Due to the complexity of this filter and since
 the focus of the course is Operating Systems and not control theory, 
measurements and odometry, this approach is discarded and a more naive, 
though effective one is chosen.
The main idea is to exploit the PID controllers based on the encoders to
 handle the dynamic behaviour of the system in a nice way and on top of 
it use the values of the gyroscope and compass to increase the accuracy.
 In other words the turn relative function based on the PID can be used 
to turn of a given angle and the PID is able to handle the dynamic 
behaviour of the robot providing a smooth response. A proportional 
controller computes the error between target and current angle using the
 gyroscope and then gives the command (divided by a constant of 4) to 
the turn relative function. Since the internal meachanism already 
handles the dynamic behavior, the proportional controller is sufficient 
it is a way to use the gyroscope better precision. This is the turn 
relative function included in the lib/ev3lib_motor library. On top of 
it, similary, a turn absolute function is built. It used a proportional 
controller and the calibrated compass values as well as the compass 
reading to reach the calibrated angle nearest to the reference one. The 
it calls the simple turn relative to make the remaining movement. This 
way the even better accuracy of the calibrated angles is exploited. In 
the end the result is very good and it does not drifts during the 
competition. The video section shows how the robot can turn perfectly of
 a given angle. Figure <i>contoller</i> shows a diagram of the overall 
system. Follows the pseudocode of a proportional controller that once 
the final position is reached exits.
<br>
</p>
<pre> while((error = reference - actual &lt; margin) ){
   command = k*error;
 }
</pre>
<p><br>
Even if the proportional controller exits, sice the command is given to the PID controller, the final position is kept in hold.
</p>
<h3><span class="mw-headline" id="Ball_detection_and_grab_with_check">Ball detection and grab with check</span></h3>
<p>This basic function is called whenever the robot reaches a position 
where he thinks there is a ball, either because he reached a predefined 
position or because he encountered something during his movements.
The main idea is to perform a scan in two directions trying to identify 
the angle at which the minimum distance from the object is found. To 
avoid considering walls as balls, a limit on the distance is set. If the
 distance is greater than this limit it is considered as infinity. Since
 the robot never goes near the wall at a distance smaller than the 
limit, the wall is never considered in the minimum computation even if 
it seen by the sensor. This procedure is repeated several times, after 
each scan the robot tunrs to the position of the minimum and then 
approaches the ball running for 3/4 of the distance from it and then 
scans again. If during the following scan the minimum is not found, the 
robot tries a second time before saying the ball is not there. Once the 
distance from the ball is less than a certain limit the robot tries to 
grab it and then checks the color sensor to see if the grab was 
successful. In case of failure it tries againg to scan and grab twice 
before saying the ball was not found. This strategy is very slow but 
really effective since the successive approximations allow the robot to 
grab the ball even if it was not really aligned to it when it stopped 
the first time and even if some errors occur due to imprecisions during 
the scans or if the ball is lost during grab.
</p>
<h3><span class="mw-headline" id="Obstacle_detection_and_avoidance">Obstacle detection and avoidance</span></h3>
<p>To detect obstacles it is simply sufficient to check the distance 
values of the ultrasonic sensor while running. A limit is set that 
allows the robot to stop before touching it. In case the obstacle is 
after the final destination point movement can be completed. Otherwise 
some action is perfomed based on the main strategy described in the 
following sections. The distance covered before the abort due to the 
obstacle is measured thanks to the encoders.
After an obstacle is found the action to take depends on the main 
strategy described in the following secions. In case it is necessary to 
avoid the obstacle an obstacle avoid function is called. This simply 
decides to turn left or right of 45 degrees depending on the robot 
position and angle in the arena. Then it makes the robot run for 40 cm. 
This decision is made thanks to a look-up in a 3D matrix of hardwired 
values wich takes as input i,j,k where i is 1 if the robot is in the 
right part of the arena, y if it is in the top part, and k can take 
values from 0 to 3 according to the quadrant in which the robot angle 
is.
</p>
<h3><span class="mw-headline" id="Go_to_position">Go to position</span></h3>
<p>To run forward of a given distance at a given speed the proper 
command is given to the motors using set_motors_speed and run_relative 
with a proper mapping between distance and angles. Once the command is 
given, the motors and sensors act as devices in parallel with the main 
application. The main application polls the status flag in the motors to
 see when the movement is completed. This basic functionality can be 
improved also checking the value of the distance given by the ultrasonic
 sensor (to detect an obstacle) and the value of the flag that indicates
 the reception of a cancel message. The basic go to position function 
exits whenever the final position is reached or a cancel message is 
received or an obstacle is found and returns this status (as well as 
updating the robot posistion). Actually, to be more precise, when an 
object is detected, if its position is after the final destination the 
movement is re-started and completed and the final exit value is 
reached. This function also allows to specify a margin to use when 
reaching the final destination. For instace it is possible to reach a 
position 40 cm before the position of the next robot given as input. If a
 movement is bigger than 200 cm it is split in several 200cm ones plus 
the remainder, in order to avoid sending distance messages bigger than 
255cm and also to re-calibrate the angle at each step.
This function can be used as it is, for instance in the leader where the
 only exit conditions are reached and obstacle and in both cases the 
action to take is to try to grab a ball. This function is then used by a
 more complex one that implements (if set as parameter) obstacle 
avoidance. Follows the pseudo code in a very simplified form:<br>
</p>
<pre>go_to_pos_int(pos){
  while( (r = goto(pos))&nbsp;!= reached ){
    if(r == obstacle) avoid()
    elsif(r == cancel) break;
  }
}
</pre>
<p>Avoid obstacle is a function that implements the strategy described in the avoid obstacle section.
</p>
<h3><span class="mw-headline" id="Blueetooth_module">Blueetooth module</span></h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Bluetooth_graph.png" class="image"><img alt="" src="index_files/300px-Bluetooth_graph.png" class="thumbimage" srcset="/mediawiki-1.26.0/images/thumb/9/90/Bluetooth_graph.png/450px-Bluetooth_graph.png 1.5x, /mediawiki-1.26.0/images/thumb/9/90/Bluetooth_graph.png/600px-Bluetooth_graph.png 2x" height="188" width="300"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Bluetooth_graph.png" class="internal" title="Enlarge"></a></div>Bluetooth</div></div></div>
<p>The bluetooth communication is handled as shown in the picture. 
Everything is managed inside library. The init function creates a socket
 and then spawns a thread. This thread executes a blocking read on the 
input buffer, whenever a message is available it calls the correspondig 
callback function that was registered during initialization. These 
callbacks can be used to execute operations driven by the message 
events. It is important to notice that when a callback is being executed
 the socket buffers incoming messages that are therefore not lost, 
however the scheduler that reads from the buffer and schedules callback 
is blocked. This means that the next message will be served only after 
the completion of the previous callback. It is thus necessary to write 
very short callbacks, for instance just to set variables in order to 
synchronize operations in the main application. Send functions with the 
message name can be invoked from the main application to send messages 
to the output buffer whenever required.
</p>
<h2><span class="mw-headline" id="Complex_functionality">Complex functionality</span></h2>
<h3><span class="mw-headline" id="Main_architecture">Main architecture</span></h3>
<p>The program is basically composed by two parts. The first one is the 
bluetooth thread that acts as scheduler for the message callbacks. The 
second one is the main that acts a scheduler for the follower, leader 
and go_back_home functions. The main and the bluetooth threads 
synchonize thanks to the callbacks that set/unset lock variables. For 
instance the main waits polling a flag that is set by a callback. This 
busy-wainting approach is not the best one at all since the waiting 
thread has to be continuously scheduled to perform the check. It would 
be better to use a mutex and a condition variable or a semaphore to make
 the waiting thread sleep while the flag is not set. Moreover the robot 
has to interpret the sensors to interpret them as events, like obstacle 
detection.
</p>
<h3><span class="mw-headline" id="FSM_description_of_the_overall_behavior">FSM description of the overall behavior</span></h3>
<p>The functionality implemented by the robot is very complex and can be
 easily modeled as a finite state machine that reacts to events such as 
messages and detection of obstacles. Pseudo-code is not as suitable as 
an FSM for this description.
Since this FSM would be extremely big, it is better to use hierarchy. 
First a high-level description of the 
idle,leader,follower,go_back_home,exit behavior is provided. Then each 
of these states is described itself as an FSM.
</p>
<h4><span class="mw-headline" id="I_am_me">I am me</span></h4>
<p><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/500px-IamMe.png" class="image" title="Overall behavior"><img alt="Overall behavior" src="index_files/500px-IamMe.png" srcset="/mediawiki-1.26.0/images/thumb/3/3b/IamMe.png/750px-IamMe.png 1.5x, /mediawiki-1.26.0/images/thumb/3/3b/IamMe.png/1000px-IamMe.png 2x" height="386" width="500"></a>
</p>
<h4><span class="mw-headline" id="Leader">Leader</span></h4>
<p>The main strategy used by the leader is described in the following.<br>
The robot first reads a file of predefined positions to reach and it 
follows the path (even several times) until a ball is found. Since a 
ball is likely to be present in each predefined position, the success is
 very probable. Thanks to the object detection feature, if a ball is 
found in an area around this path, it is detected and grabbed. Since the
 path is properly designed to cover most of the arena, also balls at 
random positions (or moved from predefined positions) can be grabbed.<br>
Tests show how efficient this algorithm is in several conditions. See the video section for several cases.<br>
<a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/500px-Leader.png" class="image" title="Leader"><img alt="Leader" src="index_files/500px-Leader.png" srcset="/mediawiki-1.26.0/images/thumb/5/50/Leader.png/750px-Leader.png 1.5x, /mediawiki-1.26.0/images/thumb/5/50/Leader.png/1000px-Leader.png 2x" height="386" width="500"></a>
</p>
<h4><span class="mw-headline" id="Follower">Follower</span></h4>
<p>The most important part of the follower algorith is the choice of the
 position where to go based on the action (or cancel) message received.
The distance to keep from the other robot is 40 cm (center to center). 
In case the preceding robot moves of a distance greater than 40 cm, the 
robot first reaches the past position of the preceding one, than it 
moves towards its new position (computed thanks to the action message), 
but it stops 40 cm before (thanks to the margin paramenter in the go_to 
function). If the distance is less than 40 cm this algorithm does not 
work. For this reason the robot first aligns itself on the line that 
links its position to the new position of the preceding robot. Then it 
moves forward or backward in order to keep a 40 cm distance from the new
 position.<br>
After having received an action message the robot waits some time before
 starting to move and the motion itself takes time (especially to turn).
 If a cancel message is received, the robot stops, but at this time it 
is not necessary at 40 cm from the preceding due to the differences in 
the beginning of the movement. So an <b>additional feature</b> of the 
cancel message is exploited to resychronize: if the robot that sends the
 cancel implements the distance field, this piece of information is 
exploited to compute where it actually stopped and complete the 'follow 
action' using that target instead of just aborting the movement. Madara 
also implements this distance feature when it has to send a cancel 
message.<br>
This algorithm proved to be very efficient during tests with team Wall_EV3.<br>
<a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/500px-Follower.png" class="image" title="Follower"><img alt="Follower" src="index_files/500px-Follower.png" srcset="/mediawiki-1.26.0/images/thumb/3/3b/Follower.png/750px-Follower.png 1.5x, /mediawiki-1.26.0/images/thumb/3/3b/Follower.png/1000px-Follower.png 2x" height="386" width="500"></a>
</p>
<h4><span class="mw-headline" id="Go_back_home">Go back home</span></h4>
<p>The main strategy to go back to the starting position is just to use 
the go_to function, exploiting its object avoidance features in case 
other obstacles are in the middle.<br>
<a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/500px-Go_back_home.png" class="image" title="go_back_home"><img alt="go_back_home" src="index_files/500px-Go_back_home.png" srcset="/mediawiki-1.26.0/images/thumb/2/24/Go_back_home.png/750px-Go_back_home.png 1.5x, /mediawiki-1.26.0/images/thumb/2/24/Go_back_home.png/1000px-Go_back_home.png 2x" height="386" width="500"></a>
</p>
<h4><span class="mw-headline" id="Get_the_ball">Get the ball</span></h4>
<p>Here a flow chart is the better approach to explain functionality also described in the basic functionality section.<br>
<a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/500px-Get_ball.png" class="image" title="get ball"><img alt="get ball" src="index_files/500px-Get_ball.png" srcset="/mediawiki-1.26.0/images/thumb/2/22/Get_ball.png/750px-Get_ball.png 1.5x, /mediawiki-1.26.0/images/2/22/Get_ball.png 2x" height="647" width="500"></a><br>
<a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/500px-Scann_ball.png" class="image" title="scann ball"><img alt="scann ball" src="index_files/500px-Scann_ball.png" srcset="/mediawiki-1.26.0/images/thumb/9/93/Scann_ball.png/750px-Scann_ball.png 1.5x, /mediawiki-1.26.0/images/thumb/9/93/Scann_ball.png/1000px-Scann_ball.png 2x" height="386" width="500"></a>
</p>
<h1><span class="mw-headline" id="Videos">Videos</span></h1>
<h2><span class="mw-headline" id="Perfect_square_after_compass_calibration">Perfect square after compass calibration</span></h2>
<p>The video shows how Madara performs a perfect tour around the arena 
after the compass calibration in four corners.
It is possible to see how after the calibration Madara is able to rotate
 perfectly in the direction of the cardinal compass points.<br>
 
 <iframe width="300" height="150" src="https://www.youtube.com/embed/XRQKZBUhkXI" frameborder="0" allowfullscreen></iframe>
</p>
<h2><span class="mw-headline" id="Perfect_360.C2.B0_turn_with_the_controller_based_on_the_gyroscope_only.">Perfect 360° turn with the controller based on the gyroscope only.</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://localhost/mediawiki-1.26.0/index.php?title=Snake_Game&amp;action=edit&amp;section=31" title="Edit section: Perfect 360° turn with the controller based on the gyroscope only.">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This video shows how the controller makes the robot perfectly turn of a given angle.<br>

<iframe width="300" height="150" src="https://www.youtube.com/embed/5aH2H0Zv7NE" frameborder="0" allowfullscreen></iframe>
<iframe width="300" height="150" src="https://www.youtube.com/embed/Jz68CfKGg8w" frameborder="0" allowfullscreen></iframe>
</p>
<h2><span class="mw-headline" id="Leader_2">Leader</span></h2>
<p>The video shows how Madara is able to reach a predefine position in 
the arena, search for a ball, take the ball and come back home avoiding 
obstacles along the path. Notice that the border of the arena is not 
considered as an obstacle<br>

<iframe width="600" height="300" src="https://www.youtube.com/embed/dcuA6EKFThM" frameborder="0" allowfullscreen></iframe>

<br>
<iframe width="600" height="300" src="https://www.youtube.com/embed/JgM385DASXQ" frameborder="0" allowfullscreen></iframe>


<br>
This video shows how Madara is able to grab the second ball since the one in the first position is not there.<br>
<iframe width="600" height="300" src="https://www.youtube.com/embed/KqzU1qcnCDc" frameborder="0" allowfullscreen></iframe>

<br>
This video shows a leader-follower test before the first deadline, when obstacle avoidance was not yet implemented.<br>
</p>
<div class="thumb tright"><div class="thumbinner">
<iframe width="300" height="170" src="https://www.youtube.com/embed/-jWaK5a4L84" frameborder="0" allowfullscreen></iframe>

<div class="thumbcaption">Leader mode</div></div></div><br>
<h2><span class="mw-headline" id="Follower_2">Follower</span></h2>
<p>The video shows how Madara is able to follow a leader until it receives a cancel messages.<br>
<iframe width="600" height="300" src="https://www.youtube.com/embed/TOAfITM8c0c" frameborder="0" allowfullscreen></iframe>

</p>
<h2><span class="mw-headline" id="Having_fun_with_Wall_EV3">Having fun with Wall_EV3</span></h2>
<p>This video shows some tests with another robot.<br>
<iframe width="600" height="300" src="https://www.youtube.com/embed/SkIcUy5U4SY" frameborder="0" allowfullscreen></iframe>
</p>
<h1><span class="mw-headline" id="How_to_work_with_EV3">How to work with EV3</span></h1>
<h2><span class="mw-headline" id="Robot_Setup">Robot Setup</span></h2>
<p>First of all we need to install the Operating System on the EV3 robot. This operation can be performed through these steps:
</p>
<ol><li> Download the image of <i>Debian for EV3</i>: we download the image from this <a rel="nofollow" class="external text" href="https://github.com/ev3dev/ev3dev/releases/download/ev3-ev3dev-jessie-2015-09-13/ev3-ev3dev-jessie-2015-09-13.img.zip">link</a> but you can find all the aviable version at this <a rel="nofollow" class="external text" href="https://github.com/ev3dev/ev3dev/releases">link</a>;</li>
<li> Copy the image file on SD card: this is not only a simple copy and 
paste but the image just donloaded represent the final state of the SD 
card. We copy the content of the image byte by byte in a row way. This 
copy overwrite the file system of SD and this operation will delete the 
SD card content. To do that we use Win32DiskImager on Windows;</li>
<li> Finally we insert the SD into EV3 and then we turn it on. The first boot takes a little longer than next boots.</li></ol>
<p>At this point we have a robot with a working Debian OS able to read 
sensors and send command to actuators. The next step is to enstablish a 
connection with our PC in order to load and write programs and better 
configure the robot.<br>
For the connection we use a USB WiFi module plugged directly in the 
robot USB port in order to connect it to a WiFi network generated by our
 PCs. We use this type of connection because it allow us to connect more
 then one PC to the robot at the same time and to work without cables.<br>
<br>
Before we start to write code we perform some initial setup:
</p>
<ol><li> Change the root password (for security porpouses);</li>
<li> Create a new user without root privileges: it is needed to execute our program by typing on the roboot user interface;</li>
<li> Download lastest debian updates;</li></ol>
<h2><span class="mw-headline" id="Source_Code">Source Code</span></h2>
<p>The source code of our project is split into multiple source files:
</p>
<ul><li> <i>bt_main7.c</i> containing the main function that implements  the strategy for the game </li>
<li> <i>calibrate.c</i>  implementing an interface with the user to perform the compass calibration </li>
<li> several source files and their relative header files ( also called 
libraries) stored in the folder lib that provide primitives for the 
sensors and functions that are used several time in the main code. </li></ul>
<p>To go deeper into details, the lib folder contains:
</p>
<ul><li> <i>ev3lib_ball.c/.h</i>&nbsp;: functions to find and grab the ball </li>
<li> <i>ev3lib_bluetooth.c/.h</i>&nbsp;: functions to implement the bluetooth protocol</li>
<li> <i>ev3lib_gui.c/.h</i>&nbsp;: functions to display errors on the robot and turn on the led</li>
<li> <i>ev3lib_motor.c/.h</i>&nbsp;: motor primitives</li>
<li> <i>ev3lib_motor_controller.c/.h</i>&nbsp;: functions to improve motor primitives by implementing PID controller</li>
<li> <i>ev3lib_sensor.c/.h</i>&nbsp;: sensor primitives</li></ul>
<p>Exsternal libraries used: 
</p>
<ul><li> <a rel="nofollow" class="external text" href="https://github.com/in4lio/ev3dev-c">ev3dev-c</a> written by @in4lio </li>
<li> <a rel="nofollow" class="external text" href="https://github.com/theZiz/ev3c">ev3c</a> written by @theZiz</li></ul>
<h2><span class="mw-headline" id="Compile_and_Linking">Compile and Linking</span></h2>
<p>In order to compile and link our project we use a Makefile.
The Makefile creates a tree of dependencies of the main program then, 
only the first time, it compiles all the libraries in order to create 
the obj files and finally it links all the obj file in order to obtain 
the final executable.
The Makefile is written is such a way the first time we have to compile 
all the libraries and then we have to compile only the library that we 
modify, in this way we save time.
To compile the main program you simply have to run:
</p>
<pre> $ make
</pre>
<p>Otherwise, if you want to compile another program that uses the library written by us you have to run:
</p>
<pre> $ make EXEC=program_name
</pre>
<p>This method does not work so well when you have to remove the battery
 due to a system crash, in fact after this operation the internal clock 
is reset and the make file generates an error called "Clock skew 
detected". In order to solve this problem you simply have to recompile 
the whole project.
</p>
<h2><span class="mw-headline" id="Download_and_run_the_project">Download and run the project</span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Wifi_module.jpg" class="image"><img alt="" src="index_files/300px-Wifi_module.jpg" class="thumbimage" srcset="/mediawiki-1.26.0/images/thumb/b/b4/Wifi_module.jpg/450px-Wifi_module.jpg 1.5x, /mediawiki-1.26.0/images/thumb/b/b4/Wifi_module.jpg/600px-Wifi_module.jpg 2x" height="225" width="300"></a>  <div class="thumbcaption"><div class="magnify"><a href="http://studwww.eurecom.fr/~lucarell/os_project/index_files/300px-Wifi_module.jpg" class="internal" title="Enlarge"></a></div>Wifi module</div></div></div>
<p>After one has connected the laptop on the same Wi-fi network of the 
robot, it is possible to load the source code on the robot using 
the <i>scp</i> command.
</p><p>It is possible to download the source code from the following links:
</p>
<ul><li> <a href="http://studwww.eurecom.fr/~lucarell/os_project/project_sources/Madara_home.zip">link</a>&nbsp;: this compressed file have to be extracted in the home folder </li>
<li> <a href="http://studwww.eurecom.fr/~lucarell/os_project/project_sources/Madara_usr_local_bin.zip">link</a>&nbsp;:  this compressed file have to be extracted in the usr/local/bin folder </li></ul>
<p>Before compiling the project one has to set the bluetooth address of 
the server by editing the define SERVER_ADDRESS inside the file 
lib/ev3lib_bluetooth.h
</p><p>At this point, run the following command from the project folder in order to compile it: 
</p>
<pre> $ make
</pre>
<p>Finally, after the bluetooth server start, run the main program:
</p>
<pre> $ ./bt_main7
</pre>
<h1><span class="mw-headline" id="Work_organization">Work organization</span></h1>
<p>The team has worked on this project constantly from mid November to 
the final competion on the 18th of January. Considering no less than 15 
hours per week for 8 weeks we estimate around 120 hours of work.<br>
By the 14th of December (first deadline) the robot was already complete 
in its current architecture and able to perform all main tasks. However 
the compass was not yet well calibrated in several arena locations and 
obstacle avoid function had not been implemented. During the development
 of the obstacle avoid function the necessity of a custom cancel message
 to add to the specification arised. This feature was implemented and 
tested with team Wall_EV3. Moreover random ball search was improved 
exploiting the obstacle detection (before the robot had to stop at 
random points and start a scan for ball, now scan for ball can be 
triggered by an obstacle detection). The color sensor to check if the 
ball was really grabbed was added to.<br><br>
The development procedure includes a brainstorming session after 
personal reflection, followed by implementation in pairs or trios. 
Debugging is made by the same sub-team and then by the one who did not 
write the code, in order to split writing and verification and improve 
the efficiency. The code is revised and rewritten cleanly by someone who
 did not write it and again it is tested by someone else. This allows to
 easily find and solve bugs.<br>
Moreover collaboration with team Wall_Ev3 allowed to test and improve the communication features between robots.<br>
</p>
<h1><span class="mw-headline" id="Work_division">Work division</span></h1>
<p>Here follows the list of the most important parts of the main along 
with the person/people who has/have worked on the main writing stage.
</p><p><b>Wrapper of basic functionalities</b> -&gt; Giovanni Camurati; Marco Lucarella;<br>
<b>Sensors calibration</b> -&gt; Giovanni Camurati; Enrico Gioia;<br>
<b>Bluetooth communication</b> -&gt; Marco Lucarella; Simone Marchisio;<br>
<b>Leader strategy</b> -&gt; Enrico Gioia;<br>
<b>Follower strategy</b> -&gt; Simone Marchisio;<br>
<b>Scan for ball</b> -&gt; All members<br>
<b>Grab the ball</b> -&gt; All members<br>
<b>Check ball grabbed</b> -&gt; Marco Lucarella; Simone Marchisio;<br>
<b>Go to position x, y</b> -&gt; Giovanni Camurati; Enrico Gioia;<br>
<b>Turn absolute using compass</b> -&gt; Giovanni Camurati;<br> 
<b>Turn relative using gyroscope</b> -&gt; Giovanni Camurati; Enrico Gioia;<br>
<b>Avoid obstacle</b> -&gt; Marco Lucarella; Enrico Gioia; Simone Marchisio;<br>
<b>Compilation</b> -&gt; Marco Lucarella;<br>
<b>Web site</b> -&gt; All members<br>
</p>
<h1><span class="mw-headline" id="Team_members">Team members</span></h1>
<p><b> Marco Lucarella </b> <br>
<b> Enrico Gioia </b> <br>
<b> Giovanni Camurati </b> <br>
<b> Simone Marchisio </b> <br>
</p>
<!-- 
NewPP limit report
Cached time: 20160117233941
Cache expiry: 86400
Dynamic content: false
Real time usage: 0.696 seconds
Preprocessor visited node count: 257/1000000
Preprocessor generated node count: 372/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key my_wiki:pcache:idhash:3-0!*!*!!en!5!* and timestamp 20160117233941 and revision id 193
 -->
</div>					<div class="printfooter">
						Retrieved from "<a dir="ltr"></a>"					</div>
				<div id="catlinks" class="catlinks catlinks-allhidden"></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li id="ca-nstab-main" class="selected"><span><a title="View the content page [Alt+Maiusc+c]" accesskey="c">Page</a></span></li>
															
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 tabindex="0" id="p-variants-label">
							<span>Variants</span><a tabindex="-1" href="#"></a>
						</h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a>Read</a></span></li>
															<li id="ca-edit"><span><a title="Edit this page [Alt+Maiusc+e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a title="Past revisions of this page [Alt+Maiusc+h]" accesskey="h">View history</a></span></li>
															<li id="ca-unwatch" class="icon"><span><a title="Remove this page from your watchlist [Alt+Maiusc+w]" accesskey="w">Unwatch</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu" aria-labelledby="p-cactions-label">
						<h3 tabindex="0" id="p-cactions-label"><span>More</span><a tabindex="-1" href="#"></a></h3>

						<div class="menu">
							<ul>
																	<li id="ca-delete">
										<a title="Delete this page [Alt+Maiusc+d]" accesskey="d">Delete</a>
									</li>
																	<li id="ca-move">
										<a title="Move this page [Alt+Maiusc+m]" accesskey="m">Move</a>
									</li>
																	<li id="ca-protect">
										<a title="Protect this page [Alt+Maiusc+=]" accesskey="=">Protect</a>
									</li>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="" id="searchform">
							<div id="simpleSearch">
							<input autocomplete="off" tabindex="1" name="search" placeholder="Search" title="Search Robot Project [Alt+Maiusc+f]" accesskey="f" id="searchInput" type="search"><input value="Special:Search" name="title" type="hidden"><input name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton" type="submit">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>

			<div class="body">
									<ul>
						<li id="n-mainpage-description"><a  title="Visit the main page [Alt+Maiusc+z]" accesskey="z">Main page</a></li><li id="n-recentchanges"><a title="A list of recent changes in the wiki [Alt+Maiusc+r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a  title="Load a random page [Alt+Maiusc+x]" accesskey="x">Random page</a></li><li id="n-help"><a title="The place to find out">Help</a></li>					</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Tools</h3>

			<div class="body">
									<ul>
						<li id="t-whatlinkshere"><a title="A list of all wiki pages that link here [Alt+Maiusc+j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a title="Recent changes in pages linked from this page [Alt+Maiusc+k]" accesskey="k">Related changes</a></li><li id="t-upload"><a title="Upload files [Alt+Maiusc+u]" accesskey="u">Upload file</a></li><li id="t-specialpages"><a  title="A list of all special pages [Alt+Maiusc+q]" accesskey="q">Special pages</a></li><li id="t-print"><a  rel="alternate" title="Printable version of this page [Alt+Maiusc+p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a  title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a title="More information about this page">Page information</a></li>					</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							
						<div style="clear:both"></div>
		</div>
		<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.loader.state({"user":"ready","user.groups":"ready"});mw.loader.load(["mediawiki.toc","mediawiki.page.patrol.ajax","mediawiki.action.view.postEdit","site","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.page.watch.ajax"]);
} );</script><script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({"wgBackendResponseTime":1371});
} );</script>
	

<div class="suggestions" style="display: none; font-size: 13px;"><div class="suggestions-results"></div><div class="suggestions-special"></div></div></body></html>
